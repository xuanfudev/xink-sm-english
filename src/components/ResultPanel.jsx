import { useEffect, useMemo, useRef, useState } from "react";
import { transcripts } from "../services/transcripts";
import {
  Brain, FileText, Star, CheckCircle2, MessageCircle, FileDigit, StickyNote, Download, BarChart2
} from "lucide-react";
import { Tabs, TabPanels } from "./Tabs";
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
const backendUrl = import.meta.env.VITE_BACKEND_URL || 'http://localhost:8000'
function HeaderCard({ item }) {
  
  console.log(item);
  
  if (!item) {
  return <div className="h-60 rounded-2xl bg-brand-100/30 animate-pulse" />;
  }
  return (
    <div className="">
      <div className="flex items-start justify-between">
        <div className="flex items-start gap-3">
          <div className="w-10 h-10 rounded-2xl bg-gradient-to-br from-brand-500 to-brand-400 text-white flex items-center justify-center shadow-sm">
            <Brain size={20} />
          </div>
          <div>
            <h2 className="text-[22px] leading-6 lg:text-[24px] text-brand-900 font-semibold tracking-tight">
              {item.title}
            </h2>
            <p className="text-[12px] text-brand-800/70 mt-0.5">AI-powered analysis results</p>
            <div className="mt-2 flex gap-2">
              <span className="pill-blue">Input: {item?.inputLang ?? "-"}</span>
              <span className="pill-green">Output: {item?.outputLang ?? "-"}</span>
        </div>
        </div>
        </div>
        <button className="px-3 py-1 rounded-xl text-white text-xs font-medium bg-blue-600 hover:bg-blue-700 shadow-sm transition">
          Edit
        </button>
      </div>
    </div>
  );
}

export default function ResultPanel({ id, refreshKey }) {
  const [item, setItem] = useState(null);
  const [tab, setTab] = useState("summary");
  const [chatInput, setChatInput] = useState("");
  const [chatOutput, setChatOutput] = useState("");
  const [chatLoading, setChatLoading] = useState(false);
  const [chatMessages, setChatMessages] = useState([]); // {role:'user'|'assistant', content:string}
  const chatEndRef = useRef(null)
  const [lastUserMessage, setLastUserMessage] = useState("");

  // DOCX Generation Functions with Vietnamese support
  const generateSummaryDOCX = async () => {
    if (!item) return;
    
    try {
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            // Title
            new Paragraph({
              children: [
                new TextRun({
                  text: "Transcript Analysis Summary",
                  bold: true,
                  size: 32,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.TITLE,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 }
            }),
            
            // Document info
            new Paragraph({
              children: [
                new TextRun({
                  text: `Document: ${item.title}`,
                  size: 24
                })
              ],
              spacing: { after: 200 }
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Created: ${new Date(item.createdAt).toLocaleDateString()}`,
                  size: 24
                })
              ],
              spacing: { after: 200 }
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Language: ${item.inputLang} â†’ ${item.outputLang}`,
                  size: 24
                })
              ],
              spacing: { after: 400 }
            }),
            
            // Summary heading
            new Paragraph({
              children: [
                new TextRun({
                  text: "Summary",
                  bold: true,
                  size: 28,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.HEADING_1,
              spacing: { after: 300 }
            }),
            
            // Summary content
            new Paragraph({
              children: [
                new TextRun({
                  text: item.summary || 'No summary available',
                  size: 24
                })
              ],
              spacing: { after: 400 }
            }),
            
            // Model info if available
            ...(item.model ? [
              new Paragraph({
                children: [
                  new TextRun({
                    text: `Generated by: ${item.model}`,
                    size: 20,
                    italics: true,
                    color: "666666"
                  })
                ],
                spacing: { after: 200 }
              })
            ] : [])
          ]
        }]
      });
      
      const buffer = await Packer.toBlob(doc);
      saveAs(buffer, `${item.title}_Summary.docx`);
      
    } catch (error) {
      console.error('Error generating DOCX:', error);
    }
  };

  const generateHighlightsDOCX = async () => {
    if (!item) return;
    
    try {
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            // Title
            new Paragraph({
              children: [
                new TextRun({
                  text: "Key Highlights",
                  bold: true,
                  size: 32,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.TITLE,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 }
            }),
            
            // Document info
            new Paragraph({
              children: [
                new TextRun({
                  text: `Document: ${item.title}`,
                  size: 24
                })
              ],
              spacing: { after: 200 }
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Created: ${new Date(item.createdAt).toLocaleDateString()}`,
                  size: 24
                })
              ],
              spacing: { after: 400 }
            }),
            
            // Highlights heading
            new Paragraph({
              children: [
                new TextRun({
                  text: "Highlights",
                  bold: true,
                  size: 28,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.HEADING_1,
              spacing: { after: 300 }
            }),
            
            // Highlights list
            ...(item.highlights && item.highlights.length > 0 
              ? item.highlights.map((highlight, index) => 
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: `${index + 1}. ${highlight}`,
                        size: 24
                      })
                    ],
                    spacing: { after: 200 }
                  })
                )
              : [
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "No highlights available",
                        size: 24,
                        italics: true
                      })
                    ],
                    spacing: { after: 200 }
                  })
                ]
            )
          ]
        }]
      });
      
      const buffer = await Packer.toBlob(doc);
      saveAs(buffer, `${item.title}_Highlights.docx`);
      
    } catch (error) {
      console.error('Error generating DOCX:', error);
    }
  };

  const generateTodosDOCX = async () => {
    if (!item) return;
    
    try {
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            // Title
            new Paragraph({
              children: [
                new TextRun({
                  text: "Action Items & To-Do List",
                  bold: true,
                  size: 32,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.TITLE,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 }
            }),
            
            // Document info
            new Paragraph({
              children: [
                new TextRun({
                  text: `Document: ${item.title}`,
                  size: 24
                })
              ],
              spacing: { after: 200 }
            }),
            
            new Paragraph({
              children: [
                new TextRun({
                  text: `Created: ${new Date(item.createdAt).toLocaleDateString()}`,
                  size: 24
                })
              ],
              spacing: { after: 400 }
            }),
            
            // Action Items heading
            new Paragraph({
              children: [
                new TextRun({
                  text: "Action Items",
                  bold: true,
                  size: 28,
                  color: "0891B2"
                })
              ],
              heading: HeadingLevel.HEADING_1,
              spacing: { after: 300 }
            }),
            
            // Todos list
            ...(item.todos && item.todos.length > 0 
              ? item.todos.map((todo, index) => [
                  // Todo title
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: `${index + 1}. ${todo.text}`,
                        bold: true,
                        size: 26
                      })
                    ],
                    spacing: { after: 200 }
                  }),
                  
                  // Todo details
                  ...(todo.priority ? [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: `Priority: ${todo.priority}`,
                          size: 22,
                          color: "666666"
                        })
                      ],
                      spacing: { after: 100 }
                    })
                  ] : []),
                  
                  ...(todo.due ? [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: `Due: ${todo.due}`,
                          size: 22,
                          color: "666666"
                        })
                      ],
                      spacing: { after: 100 }
                    })
                  ] : []),
                  
                  ...(todo.owner_hint ? [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: `Owner: ${todo.owner_hint}`,
                          size: 22,
                          color: "666666"
                        })
                      ],
                      spacing: { after: 100 }
                    })
                  ] : []),
                  
                  ...(todo.rationale ? [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: `Rationale: ${todo.rationale}`,
                          size: 22,
                          color: "666666"
                        })
                      ],
                      spacing: { after: 300 }
                    })
                  ] : [])
                ]).flat()
              : [
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "No action items available",
                        size: 24,
                        italics: true
                      })
                    ],
                    spacing: { after: 200 }
                  })
                ]
            )
          ]
        }]
      });
      
      const buffer = await Packer.toBlob(doc);
      saveAs(buffer, `${item.title}_ToDos.docx`);
      
    } catch (error) {
      console.error('Error generating DOCX:', error);
    }
  };


  function formatDate(d) {
    try {
      const date = new Date(d);
      return isNaN(date) ? d : date.toLocaleDateString("vi-VN");
    } catch { return d; }
  }

  useEffect(() => {
    if (!id) return;
    setItem(null);                      // reset state khi Ä‘á»•i id
    transcripts.get(id).then(setItem);
  }, [id, refreshKey]);

  useEffect(()=>{ chatEndRef.current?.scrollIntoView({ behavior:'smooth' }) }, [chatMessages])

  // ðŸ‘‡ luÃ´n Ä‘Æ°á»£c gá»i á»Ÿ má»i render
  const tabs = useMemo(() => {
    const it = item ?? {};
    return [
      {
        id: "summary",
        label: "Summary",
        
        render: () => (
          <section className="card p-6">
            <header className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-2xl bg-purple-600 text-white flex items-center justify-center">
                  <FileText size={18} />
                </div>
                <h3 className="text-cyan-900 font-semibold text-lg">Meeting Summary</h3>
              </div>
              <div className="flex gap-2">
                <button 
                  onClick={generateSummaryDOCX}
                  className="flex items-center gap-2 px-3 py-1.5 rounded-xl text-cyan-600 hover:bg-cyan-50 transition-colors text-sm font-medium"
                >
                  <Download size={16} />
                  Download 
                </button>
                <button className="btn-ghost">Translate</button>
              </div>
            </header>
            <p className="mt-4 text-cyan-900/90 leading-7">
              {it.summary ?? "Generating summaryâ€¦"}
            </p>
          </section>
        ),
      },
      {
        id: "highlights",
        label: "Highlights",
      
        render: () => (
          <section className="card p-6">
            <header className="flex items-center justify-between mb-1.5">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-2xl bg-pink-500 text-white flex items-center justify-center">
                  <Star size={18} />
                </div>
                <h3 className="text-cyan-900 font-semibold text-lg">Key Highlights</h3>
              </div>
              <div className="flex gap-2">
                <button 
                  onClick={generateHighlightsDOCX}
                  className="flex items-center gap-2 px-3 py-1.5 rounded-xl text-cyan-600 hover:bg-cyan-50 transition-colors text-sm font-medium"
                >
                  <Download size={16} />
                  Download 
                </button>
                <button className="btn-ghost">Translate</button>
              </div>
            </header>
            <ul className="list-disc pl-6 space-y-2.5 text-cyan-900/90">
              {(it.highlights?.length ? it.highlights : ["â€¦"]).map((h, i) => <li key={i}>{h}</li>)}
            </ul>
          </section>
        ),
      },
      {
        id: "todo",
        label: "To-Do",
       
        render: () => (
          <section className="card p-6">
            <header className="flex items-center justify-between mb-1.5">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-2xl bg-emerald-600 text-white flex items-center justify-center">
                  <CheckCircle2 size={18} />
                </div>
                <h3 className="text-cyan-900 font-semibold text-lg">Action Items</h3>
              </div>
              <div className="flex gap-2">
                <button 
                  onClick={generateTodosDOCX}
                  className="flex items-center gap-2 px-3 py-1.5 rounded-xl text-cyan-600 hover:bg-cyan-50 transition-colors text-sm font-medium"
                >
                  <Download size={16} />
                  Download 
                </button>
                <button className="btn-ghost">Translate</button>
              </div>
            </header>
            <div className="h-96 overflow-y-auto pr-1">
            <ul className="space-y-2.5 text-cyan-900/90">
           
  {(it.todos ?? []).map((td, idx) => {
    const key = `${td.text}-${td.due ?? idx}`;
    const priColor =
      td.priority === "high" ? "bg-red-100 text-red-700" :
      td.priority === "medium" ? "bg-yellow-100 text-yellow-700" :
      "bg-gray-100 text-gray-700";

    return (
      <li key={key} className="flex flex-col gap-1 rounded-lg border p-3">
        <div className="flex items-center gap-2">
          <input type="checkbox" className="peer accent-cyan-500" />
          <span className="transition peer-checked:line-through peer-checked:text-gray-400">
          {td.text}
        </span>

          {td.priority && (
            <span className={`ml-auto inline-flex items-center rounded px-2 py-0.5 text-xs ${priColor}`}>
              {td.priority}
            </span>
          )}
        </div>

        <div className="flex flex-wrap items-center gap-3 pl-7 text-sm text-gray-600">
          {td.due && <span>ðŸ—“ {formatDate(td.due)}</span>}
          {td.owner_hint && <span>ðŸ‘¤ {td.owner_hint}</span>}
        </div>

        {td.rationale && (
          <p className="pl-7 text-sm text-gray-700">{td.rationale}</p>
        )}
      </li>
    );
  })}


          </ul>
        </div>
          </section>
        ),
      },
      {
        id: "chat",
        label: "Chat with AI",
        
        render: () => (
          <section className="card p-6">
            {!chatOutput && chatMessages.length===0 && (
              <div className="h-64 rounded-2xl border border-cyan-200/60 flex items-center justify-center text-center mb-4 bg-cyan-50/30">
                <div>
                  <div className="w-14 h-14 rounded-2xl bg-blue-600 text-white flex items-center justify-center mx-auto mb-3">
                    <MessageCircle size={24} />
                  </div>
                  <div className="text-cyan-900 font-semibold mb-1">Start a conversation</div>
                  <div className="text-cyan-800/80 text-sm">Ask questions about your meeting transcript</div>
          </div>
        </div>
      )}
            {chatMessages.length>0 && (
              <div className="mb-4 h-96 overflow-y-auto rounded-2xl border border-cyan-200/60 bg-white p-3 text-sm">
                <div className="space-y-3">
                  {chatMessages.map((m,i)=> (
                    <div key={i} className={m.role==='user' ? 'flex justify-end' : 'flex justify-start'}>
                      {m.role==='assistant' ? (
                        <div className="max-w-[90%] rounded-2xl bg-cyan-50 border border-cyan-200/60 px-3 py-2 text-cyan-900">
                          <div className="prose prose-sm max-w-none" dangerouslySetInnerHTML={{__html: renderMarkdown(m.content)}} />
                        </div>
                      ) : (
                        <div className="max-w-[90%] rounded-2xl bg-cyan-600 text-white px-3 py-2 whitespace-pre-wrap">{m.content}</div>
                      )}
                    </div>
                  ))}
                  <div ref={chatEndRef} />
          </div>
        </div>
      )}
            <div className="flex gap-2">
              <input
                className="flex-1 rounded-2xl border border-cyan-200/60 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-300"
                placeholder="Ask anything about the transcript..."
                value={chatInput}
                onChange={(e)=>setChatInput(e.target.value)}
                onKeyDown={async (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(!chatLoading && chatInput.trim()) await sendChat(it, chatInput) } }}
              />
              <button
                onClick={async ()=>{ if(!chatLoading && chatInput.trim()) await sendChat(it, chatInput) }}
                disabled={chatLoading || !chatInput.trim()}
                className="rounded-2xl bg-cyan-600 hover:bg-cyan-700 disabled:opacity-50 text-white px-4 py-2"
              >
                {chatLoading ? '...' : 'âž¤'}
              </button>
            </div>
          </section>
        ),
      },
      {
        id: "full",
        label: "Full Transcript",
       
        render: () => (
          <section className="card p-6">
            <header className="flex items-center gap-3 mb-4">
              <div className="w-10 h-10 rounded-2xl bg-slate-600 text-white flex items-center justify-center">
                <FileDigit size={18} />
              </div>
              <div>
                <h3 className="text-cyan-900 font-semibold text-lg">Full Transcript</h3>
                <p className="text-cyan-800/80 text-sm">
                  {item?.isLiveMeeting ? 'Live meeting transcript' : 'Complete conversation text'}
                </p>
              </div>
            </header>
            
            <div className="h-96 overflow-y-auto pr-1">
              {item?.isLiveMeeting && item?.segments?.length > 0 ? (
                <div className="space-y-3">
                  {item.segments.map((segment) => (
                    <div key={segment.id} className="border border-cyan-100 rounded-lg p-3">
                      <div className="flex items-center justify-between mb-2">
                        <div className="text-xs font-medium text-cyan-600">{segment.speaker}</div>
                        {(segment.start || segment.end) && (
                          <div className="text-xs text-cyan-600/70">
                            {segment.start != null ? `${(segment.start).toFixed ? segment.start.toFixed(1) : segment.start}s` : ""} 
                            {segment.end != null ? ` â†’ ${(segment.end).toFixed ? segment.end.toFixed(1) : segment.end}s` : ""}
                          </div>
                        )}
                      </div>
                      <div className="text-sm text-cyan-900 leading-relaxed">{segment.text}</div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="space-y-3">
                  {item?.text?.split('\n').map((line, idx) => (
                    <div key={idx} className="text-sm text-cyan-900 leading-relaxed">
                      {line}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </section>
        ),
      },
      
      
    ];
  }, [item, chatInput, chatLoading, chatOutput]);

  // chá»‰ return sá»›m khi chÆ°a cÃ³ id
  if (!id) return <div className="text-gray-400">Upload or record to see results.</div>;

  async function sendChat(it, message){
    try{
      setChatLoading(true)
      setChatOutput('')
      setChatMessages(prev => [...prev, { role:'user', content: message }])
      // Build a minimal payload the API can accept
      const todos = (it.todos || []).map(t => ({
        task: t.text || t.task || '',
        rationale: t.rationale || '',
        priority: t.priority || '',
        due: t.due || '',
        owner_hint: t.owner_hint || ''
      }))
      setChatInput('')
      const payload = {
        summary: it.summary || '',
        highlights: Array.isArray(it.highlights) ? it.highlights : [],
        todos: todos.map(t => ({
          task: t.task || '',
          due: t.due || '',
          owner_hint: t.owner_hint || '',
          priority: t.priority || '',
          rationale: t.rationale || ''
        })),
        message: message
      }
      const res = await fetch(`${backendUrl}/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      if(!res.ok){
        const errText = await res.text().catch(()=> '')
        throw new Error(`Chat failed: ${res.status}${errText? ' - '+errText: ''}`)
      }
      const data = await res.json()
      // Store only in chatMessages to avoid duplicate rendering
      setChatOutput('')
      setChatMessages(prev => [...prev, { role:'assistant', content: data.output || '' }])
      
    }catch(err){
      console.error('Chat error:', err)
      setChatOutput(`Error: ${err.message}`)
    }finally{
      setChatLoading(false)
    }
  }

  function renderMarkdown(md){
    if(!md) return ''
    let html = md
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/(^|\n)\s*\d+\.\s+([^\n]+)/g, '$1<li>$2</li>')
      .replace(/(^|\n)\s*[-â€¢]\s+([^\n]+)/g, '$1<li>$2</li>')
    html = html.replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>')
    html = html.replace(/\n/g, '<br/>')
    return html
  }

  return (
    <div className="space-y-4">
      <HeaderCard item={item} />
      <Tabs items={tabs} current={tab} onChange={setTab} />
      <TabPanels items={tabs} current={tab} />
    </div>
  );
}
